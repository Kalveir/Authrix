// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: permission.sql

package repository

import (
	"context"
)

const AddPermissionRole = `-- name: AddPermissionRole :exec
INSERT INTO role_permission (id_role, id_permission) SELECT $1 AS role_id_params,
unnested_permission_id FROM UNNEST($2::int[]) AS unnested_permission_id
`

type AddPermissionRoleParams struct {
	IDRole  int32   `json:"id_role"`
	Column2 []int32 `json:"column_2"`
}

func (q *Queries) AddPermissionRole(ctx context.Context, arg AddPermissionRoleParams) error {
	_, err := q.db.Exec(ctx, AddPermissionRole, arg.IDRole, arg.Column2)
	return err
}

const CreatePermission = `-- name: CreatePermission :exec
INSERT INTO permission (name) VALUES ($1)
`

func (q *Queries) CreatePermission(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, CreatePermission, name)
	return err
}

const DeletePermission = `-- name: DeletePermission :exec
DELETE FROM permission WHERE id=$1
`

func (q *Queries) DeletePermission(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeletePermission, id)
	return err
}

const DeletePermissionRole = `-- name: DeletePermissionRole :exec
DELETE FROM role_permission WHERE id_role = $1
`

func (q *Queries) DeletePermissionRole(ctx context.Context, idRole int32) error {
	_, err := q.db.Exec(ctx, DeletePermissionRole, idRole)
	return err
}

const GetPermission = `-- name: GetPermission :one
SELECT id, name FROM permission WHERE id = $1
`

type GetPermissionRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetPermission(ctx context.Context, id int32) (GetPermissionRow, error) {
	row := q.db.QueryRow(ctx, GetPermission, id)
	var i GetPermissionRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const GetPermissionRole = `-- name: GetPermissionRole :one
SELECT
    r.name AS role_name,
    STRING_AGG(p.name, ', ') AS permissions_list
FROM
    "public"."role" AS r
JOIN
    "public".role_permission AS rp ON r.id = rp.id_role
JOIN
    "public".permission AS p ON rp.id_permission = p.id
WHERE
    r.id = $1
GROUP BY
    r.id, r.name
ORDER BY
    r.name
`

type GetPermissionRoleRow struct {
	RoleName        string `json:"role_name"`
	PermissionsList []byte `json:"permissions_list"`
}

func (q *Queries) GetPermissionRole(ctx context.Context, id int32) (GetPermissionRoleRow, error) {
	row := q.db.QueryRow(ctx, GetPermissionRole, id)
	var i GetPermissionRoleRow
	err := row.Scan(&i.RoleName, &i.PermissionsList)
	return i, err
}

const ListPermission = `-- name: ListPermission :many
SELECT id, name, created_at FROM permission
`

func (q *Queries) ListPermission(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, ListPermission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPermissionRole = `-- name: ListPermissionRole :many
SELECT
    CASE
        WHEN ROW_NUMBER() OVER (PARTITION BY r.id ORDER BY p.name) = 1 THEN r.name
        ELSE NULL
    END AS role_name,
    p.name AS permission_name,
    p.id AS permission_id
FROM
    "public"."role" AS r
JOIN
    "public".role_permission AS rp ON r.id = rp.id_role
JOIN
    "public".permission AS p ON rp.id_permission = p.id
WHERE
    r.id IN ($1::int[])
ORDER BY
    r.name, p.name
`

type ListPermissionRoleRow struct {
	RoleName       interface{} `json:"role_name"`
	PermissionName string      `json:"permission_name"`
	PermissionID   int32       `json:"permission_id"`
}

func (q *Queries) ListPermissionRole(ctx context.Context, dollar_1 []int32) ([]ListPermissionRoleRow, error) {
	rows, err := q.db.Query(ctx, ListPermissionRole, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPermissionRoleRow{}
	for rows.Next() {
		var i ListPermissionRoleRow
		if err := rows.Scan(&i.RoleName, &i.PermissionName, &i.PermissionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePermission = `-- name: UpdatePermission :exec
UPDATE permission SET name=$2 WHERE id=$1
`

type UpdatePermissionParams struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) error {
	_, err := q.db.Exec(ctx, UpdatePermission, arg.ID, arg.Name)
	return err
}

const UpdatePermissionRole = `-- name: UpdatePermissionRole :exec
DELETE FROM role_permission
WHERE id_role = $1
AND id_permission NOT IN (SELECT unnested_permission_id FROM UNNEST($2::int[]) AS unnested_permission_id)
`

type UpdatePermissionRoleParams struct {
	IDRole  int32   `json:"id_role"`
	Column2 []int32 `json:"column_2"`
}

func (q *Queries) UpdatePermissionRole(ctx context.Context, arg UpdatePermissionRoleParams) error {
	_, err := q.db.Exec(ctx, UpdatePermissionRole, arg.IDRole, arg.Column2)
	return err
}

const VerifyPermission = `-- name: VerifyPermission :many
SELECT DISTINCT id FROM permission WHERE id = ANY($1:: int[])
`

func (q *Queries) VerifyPermission(ctx context.Context, dollar_1 []int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, VerifyPermission, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
